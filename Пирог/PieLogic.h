#pragma once

#include <vector>
#include <cassert>
#include <iostream>
//Сбредил для вас -- Ошлаков Данил, ИВТ-22
/*
Задача Отравленный пирог
Для игры «Отравленный пирог» используется прямоугольный пирог, разделенный на M «строк» горизонтальными разрезами и на N «столбцов» –
вертикальными. Таким образом, пирог должен быть разбит на M × N клеток, правая нижняя из которых «отравлена». Играют двое игроков, ходы
делаются по очереди. Каждый ход заключается в том, что игрок выбирает одну из еще не съеденных клеток пирога и съедает все клетки,
расположенные левее и выше выбранной (в том числе и выбранную). Проигрывает тот, кто съедает отравленную клетку. Требуется написать программу,
которая по заданной игровой позиции определяет все возможные выигрышные ходы для начинающего в этой позиции. Входные данные Данные во входном
файле расположены в следующем порядке: M, N (1 ≤ M, N ≤ 9), X1, ...,XM. Здесь Xi – число оставшихся клеток в i-м снизу горизонтальном ряду.
Все числа во входном файле разделяются пробелами и/или символами перевода строки. Выходные данные В первую строку выходного файла необходимо
вывести количество различных выигрышных ходов К, а в последующие K строк – сами выигрышные ходы. Каждый ход задается парой чисел (i, j),
где i – номер (снизу) горизонтального ряда, а j –номер (справа) вертикального ряда, которому принадлежит выбранная клетка (1 ≤ i ≤ M, 1≤ j ≤ N).
Пример входного файла
*/

#pragma once
using namespace std;

// Процедура для выбора случайного элемента массива, который не равен нулю. Возвращает индекс
pair<int, int> randChoice(vector<vector<int>>& matrix);

// Процедура для выбора случайного элемента массива, который не равен нулю. Параметры lim отвечают за то, до какой строки и столбца с конца проверять. Возвращает индекс.
pair<int, int> randChoice(vector<vector<int>>& matrix, int rowLim, int colLim);

// Процедура для проверки, заполнена ли матрица только 0
bool matrix0(vector<vector<int>>& matrix);

// Процедура для проверки, заполнена ли матрица только 0, ограниченная снизу и справа
bool matrix0LR(vector<vector<int>>& matrix);

// Процедура для проверки, заполнена ли матрица только 0, ограниченная снизу и справа на dev
bool matrix0LR(vector<vector<int>>& matrix, int devRow, int devCol);

// Процедура для печати массива
void print_matrix(vector<vector<int>>& matrix);

// Процедура для пожирания элемента массива и всего что слева и сверху. Резалт здесь для отслеживания ходов по условию задачи
pair<int, int> devour(vector<vector<int>>& matrix, unsigned row, unsigned col);

// Процедура для пожирания элемента массива и всего что слева и сверху (без учета введенных координат)
void devourV(vector<vector<int>>& matrix, unsigned row, unsigned col);

//Число ненулевых элементов в крайнем нижней строке
int n0BR(vector<vector<int>>& matrix);

//Число ненулевых элементов в крайнем справа столбце
int n0RC(vector<vector<int>>& matrix);

//Анализ ситуации
pair<int, int> termine(vector<vector<int>>& matrix);

//Запуск игры (умный против умного)
void executeSmVsSm(vector<vector<int>>& matrix);

//Запуск игры (умный против не очень умного)
void executeSmVsSt(vector<vector<int>>& matrix);

//Запуск игры (умный против человека)
void executeSmVsH(vector<vector<int>>& matrix);

//Тестирование функций
void test();

// Процедура для создания и заполнения матрицы целых чисел row × col элементов
vector<vector<int>> create_matrix(int row, int col);
